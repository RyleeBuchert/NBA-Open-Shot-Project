---
title: "NBA Open Shot Project"
author: "Rylee Buchert"
date: '2022-08-03'
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

### Introduction

The MLB has seen a considerable rise in so-called "three true outcomes" baseball due in large part to modern analytics. The heavy focus on advanced statistical metrics such as barrels, launch angle, and spin rate have led to a proliferation in home runs and strikeouts across the league. These new methods of characterizing the game provide analysts a way to evaluate players based on attributes likely to produce good outcomes without relying solely on outcome-based statistics. 

I have always been intrigued by the potential application of this idea in NBA stats. Under current practices, every event is treated equal in the scorebook. A rebound with no defenders nearby is weighed the same as a contested board. This beautiful pass by Josh Giddey to find a wide open Tre Mann is valued the same as KD handing Kyrie the ball before an unbelivable contested 3.

<center>
![](img/giddey_assist.gif){width=45%} ![](img/kyrie_3.gif){width=45%}
</center>

A great pass to an open three who misses  . Players can be making great pass

Not all hits are created equal. The idea of tracking barrels/launch angle 

Not all shots are created equal

Any offensive scheme has the goal of generating shots with a high percentage of scoring. 

The goal of this project is to isolate 'open' shots where a player is shooting without a defender immediately nearby. This metric can help when analyzing the ability of offenses go produce high-percentage shots and the strengh of defenses in preventing easy looks. Moreover, 

Unfortunately, there is not a wide breadth of public data available to determine what shots have a contesting defender. The NBA uses an array of cameras and tracking software, known as SportsVU, to record game data, but this information is not generally accessible to the public. The good news is that one season's game tracking data is posted online, conveniently posted on [Kaggle](https://www.kaggle.com/datasets/dansbecker/nba-shot-logs).

This dataset contains the records of over 100,000 shots taken during the 2014-15 NBA season, including information about where the shot was taken, game time, and who was the closest defender. Most importantly, each shot has a measure of how far the closest the closest defender was away from the shooter, providing a way to quantify if each shot had a contesting defender.

### What Counts as an "Open" Shot

Although the concept of an open look makes sense abstractly, it is harder to quantitatively define for data labeling. Ideally, this would include every shot where the shooter is out of reach of the nearest defender. Yet, this idea can vary considerably depending on the defender and court positioning. This makes it sub-optimal to define a set "circle", say 3~5 feet around a shooter, that defines their open shot zone.

Instead, I decided to label these shots based on the wingspan of the closest defender. A defender's wingspan allows me to roughly express an 'arm length' away, which I defined as the distance required for an uncontested look. According to this rule, every record where a shooter is more than half the closest defender's arm length away is an open shot, and the rest are contested. Although this definition is not perfect, it is a good starting point for investigating this idea with the data publicly available.

### Obtaining the Data

The first step is to load all of the required R packages and the dataset into the environment. For this project, I utilized the tidyverse, modelr, and ggplot2 R packages.

```{r load-data-packages, message=FALSE}
library(tidyverse)
library(modelr)
library(ggplot2)
library(ggrepel)
shot_data <- read_csv('shot_data.csv')

```

Player wingspan data is not as readily available online as I initially thought it would be. I was only able to find one [website](https://www.nbasavant.com/) which contained wingspan data for the player IDs included in the dataset. Using Python and the BeautifulSoup package, I wrote a quick web scraping function to return the wingspan for a player when given their ID.

```{python add-wingspan, error=TRUE, include=TRUE, eval=FALSE}
# Required packages
import requests
from bs4 import BeautifulSoup
import pandas as pd

# Function to return wingspan from NBAsavant.com
def get_wingspan(player_id):
    # Scrape html from url
    url = f"http://nbasavant.com/player.php?player_id={player_id}"
    soup = BeautifulSoup(requests.get(url).content, 'html5lib')
    
    # Extract and return wingspan from data
    try:
        player_data = soup.find_all("div", {"id": "boxes"})
        player_text = player_data[0].find("br").next
        wingspan = float(player_text.split('Wingspan: ', 1)[1][:5])
        return(wingspan)
    except:
        return('NA')

# Load shot dataset and apply scraping function
shot_data = pd.read_csv('shot_data.csv')
shot_data['closest_def_wingspan'] = shot_data.apply(lambda row: get_wingspan(row['closest_defender_id']), axis=1)
shot_data.to_csv('shot_data.csv')

```

Unfortunately, this only returned usable data for some of the players in the shot data.

```{r analyse-shot-data}
# Get data where wingspan is available
available_data <- shot_data %>%
  filter(!is.na(closest_def_wingspan))

# Get dataset of 'na' values
na_data <- shot_data %>%
  filter(is.na(closest_def_wingspan))

print(nrow(available_data) / nrow(shot_data))
```

Only a little over two-thirds of the records contain wingspan data after scraping. To fill in the remaining data, I decided to make predictions for player wingspans based on their height. Data for player heights are more readily available online and can be used in a regression to predict wingspans with fairly high accuracy. While this method does not give perfect information about each defender's wingspan, the predicted values still provide useful data relative to each defender and allow me to use the entire dataset.

To obtain player heights, I wrote another BeautifulSoup scraping function which scraped height from [NBA's player pages](https://www.nba.com/players). I also collected each player's position in the function for use later in this analysis. This code snippet produces a player information CSV file which then joined with the shot data after creation.

```{python add-height-pos, error=TRUE, include=TRUE, eval=FALSE}
# Function to scrape player's height and position
def get_height_position(player_id):
    # Scrape html from url
    url = f"https://www.nba.com/player/{player_id}"
    soup = BeautifulSoup(requests.get(url).content, 'html5lib')

    # Get height from data
    try:
        height_data = soup.find_all("p", {"class": "PlayerSummary_playerInfoValue__mSfou"})
        height_text = height_data[0].contents[0].split(' ')[0].split("\'")
        height = (int(height_text[0])*12) + int(height_text[1].replace("\"", ""))
    except:
        height = 'NA'

    # Get position from data
    try:
        position_data = soup.find_all("p", {"class": "t11 md:t2"})
        position_text = position_data[0].contents[0].split('|')
        position = position_text[2].strip(" ")
    except:
        position = 'NA'

    return (height, position)

# Load shot data and get all unique player id's 
shot_data = pd.read_csv('shot_data.csv')
shooter_list = shot_data.player_id.unique().tolist()
defender_list = shot_data.closest_defender_id.unique().tolist()
player_df = pd.DataFrame(set(shooter_list + defender_list)).rename(columns={0: 'player_id'})

# Create cols for height/position and save player info dataframe
player_df['height'] = player_df.apply(lambda row: get_height_position(row['player_id'])[0], axis=1)
player_df['position'] = player_df.apply(lambda row: get_height_position(row['player_id'])[1], axis=1)
player_df.to_csv('player_info.csv')

```

```{r join-player-data}
player_info <- read_csv('2015_player_info.csv')
shot_data <- shot_data %>%
  left_join(player_info, by="player_id")

```

Regression for wingspan

```{r predicting-wingspan}
# Run regression and predict 'na' wingspan values
wingspan_reg <- lm(closest_def_wingspan~closest_def_height, data=available_data)
na_data <- add_predictions(na_data, wingspan_reg, var="closest_def_wingspan", type=NULL)
na_data$closest_def_wingspan <- round(na_data$closest_def_wingspan, digit=2)

# Combine datasets
wingspan_data <- rbind(available_data, na_data)

# Convert defender distance to inches
wingspan_data$closest_def_distance_in <- 12 * wingspan_data$closest_defender_distance

# Add team codes from matchup
wingspan_data <- wingspan_data %>%
  mutate(team_name = if_else(nchar(matchup)==24, 
                            if_else(location=="H", 
                                    substr(matchup,22,24), 
                                    substr(matchup,16,18)), 
                            if_else(location=="H", 
                                    substr(matchup,16,18), 
                                    substr(matchup,24,26))),
         opp_team_name = if_else(nchar(matchup)==24, 
                            if_else(location=="H", 
                                    substr(matchup,16,18), 
                                    substr(matchup,22,24)), 
                            if_else(location=="H", 
                                    substr(matchup,24,26), 
                                    substr(matchup,16,18)))) %>%
  relocate(team_name, .after=location) %>%
  relocate(opp_team_name, .after=team_name)

# Drop unneeded columns
wingspan_data <- wingspan_data %>%
  select(-game_clock, -shot_clock, -dribbles, -touch_time)

```

Label open shots

```{r label-shots}
# Add open shot based on closest defender wingspan and distance
shot_data <- wingspan_data %>%
  mutate(open_shot = ifelse(closest_def_distance_in > (closest_def_wingspan / 2), 1, 0)) %>%
  filter(!is.na(open_shot))
```


Describe open shot stat

```{r}
# Drop missing values and get counts for open/contested shot
shot_data %>% 
  drop_na() %>%
  group_by(open_shot) %>% 
  summarise(count = n(), pct = n()/nrow(shot_data)*100)
```

Add BBref game id for boxscore data

```{r}

# Add team codes from matchup and for BBRef data
shot_data <- shot_data %>%
  mutate(home_team_short = if_else(location=="H", substr(matchup, 16, 18), substr(matchup, 22, 24)),
         away_team_short = if_else(location=="H", substr(matchup, 24, 26), substr(matchup, 16, 18))) %>%
  mutate(bbr_game_id = home_team_short) %>%
  mutate(bbr_game_id = replace(bbr_game_id, bbr_game_id == 'BKN', 'BRK')) %>%
  mutate(bbr_game_id = replace(bbr_game_id, bbr_game_id == 'PHX', 'PHO')) %>%
  mutate(bbr_game_id = replace(bbr_game_id, bbr_game_id == 'CHA', 'CHO')) %>%
  mutate(bbr_team_id = team_name) %>%
  mutate(bbr_team_id = replace(bbr_team_id, bbr_team_id == 'NOP', 'NOH')) %>%
  mutate(bbr_team_id = replace(bbr_team_id, bbr_team_id == 'BKN', 'NJN')) %>%
  mutate(bbr_team_id = replace(bbr_team_id, bbr_team_id == 'PHX', 'PHO')) %>%
  relocate(bbr_team_id, .after=team_name) %>%
  mutate(bbr_opp_team_id = opp_team_name) %>%
  mutate(bbr_opp_team_id = replace(bbr_opp_team_id, bbr_opp_team_id == 'NOP', 'NOH')) %>%
  mutate(bbr_opp_team_id = replace(bbr_opp_team_id, bbr_opp_team_id == 'BKN', 'NJN')) %>%
  mutate(bbr_opp_team_id = replace(bbr_opp_team_id, bbr_opp_team_id == 'PHX', 'PHO')) %>%
  relocate(bbr_opp_team_id, .after=opp_team_name)

# Add BBRef game id
month_convert = c(
  "JAN"="01",
  "FEB"="02",
  "MAR"="03",
  "OCT"="10",
  "NOV"="11",
  "DEC"="12"
)

shot_data <- shot_data %>%
  mutate(bbr_game_id = paste(substr(matchup, 9, 12), month_convert[substr(matchup, 0, 3)], substr(matchup, 5, 6), "0", bbr_game_id, sep="")) %>%
  relocate(bbr_game_id, .after=game_id)

```



```{r}
# Get boxscore data
boxscore_data <- read_csv("2015_games.csv") %>%
  select(game_id, opp_team_id, fg, fga) %>%
  rename(fga_total = fga, fg_total = fg)

```

```{r}

# Get shot data for all games in dataset
league_offense_summary <- shot_data %>%
  group_by(bbr_team_id, bbr_game_id, bbr_opp_team_id) %>%
  summarise(
    fg = sum(fgm),
    fga = n(),
    fg_pct = fg / fga,
    open_shots = sum(open_shot),
    open_shot_pct = open_shots / fga
  ) %>%
  left_join(boxscore_data, by=c('bbr_game_id'='game_id', 'bbr_opp_team_id'='opp_team_id')) %>%
  mutate(pred_open_shots = open_shots/(fga/fga_total))

```

```{r}

# Highest open shot percentage
league_offense_summary %>%
  group_by(bbr_team_id) %>%
  summarise(
    open_shot_pct = mean(open_shot_pct)
  ) %>%
  arrange(desc(open_shot_pct))

```

```{r}

# Most predicted open shots per game
league_offense_summary %>%
  group_by(bbr_team_id) %>%
  summarise(
    open_shots_pg = mean(pred_open_shots)
  ) %>%
  arrange(desc(open_shots_pg))

```

```{r}

# Get defensive summary for all games
league_defense_summary <- shot_data %>%
  group_by(bbr_opp_team_id, bbr_game_id, bbr_team_id) %>%
  summarise(
    opp_fg = sum(fgm),
    opp_fga = n(),
    opp_fg_pct = opp_fg / opp_fga,
    opp_open_shots = sum(open_shot),
    opp_open_shot_pct = opp_open_shots / opp_fga
  ) %>%
  left_join(boxscore_data, by=c('bbr_game_id'='game_id', 'bbr_opp_team_id'='opp_team_id')) %>%
  mutate(pred_opp_open_shots = opp_open_shots/(opp_fga/fga_total)) %>%
  rename(team = bbr_opp_team_id, opp_team = bbr_team_id)
  
```
```{r}

# Get defenses with the fewest percent of open shots allowed
league_defense_summary %>%
  group_by(team) %>%
  summarise(
    opp_open_shot_pct = mean(opp_open_shot_pct)
  ) %>%
  arrange(opp_open_shot_pct)


```

```{r}

# Get defenses with the fewest open shots allowed per game
league_defense_summary %>%
  group_by(team) %>%
  summarise(
    opp_open_shot_pg = mean(pred_opp_open_shots)
  ) %>%
  arrange(opp_open_shot_pg)

```
```{r}

# Get open shots/percentages for individual players
shooter_summary <- shot_data %>%
  group_by(player_id, player_name) %>%
  summarise(
    fg = sum(fgm),
    fga = n(),
    fg_pct = fg / fga,
    open_shots = sum(open_shot),
    open_shot_pct = open_shots / fga
  ) %>%
  arrange(desc(open_shots))


```

```{r}

# Best shooters when uncontested
shot_data %>%
  filter(open_shot == 1) %>%
  group_by(player_id, player_name) %>%
  summarise(
    fg = sum(fgm),
    fga = n(),
    open_fg_pct = fg / fga
  ) %>%
  filter(fga >= 50) %>%
  arrange(desc(open_fg_pct))

```


```{r}

# Best shooters when contested
shot_data %>%
  filter(open_shot == 0) %>%
  group_by(player_id, player_name) %>%
  summarise(
    fg = sum(fgm),
    fga = n(),
    open_fg_pct = fg / fga
  ) %>%
  filter(fga >= 50) %>%
  arrange(desc(open_fg_pct))

```
```{r}

```


```{r}
team_season <- read_csv("2015_team_season.csv")

offensive_rating <- team_season%>%
  select(Tm, win_pct, ORtg) %>%
  rename(bbr_team_id = Tm)

os_pct_offense <- league_offense_summary %>%
  group_by(bbr_team_id) %>%
  summarise(
    open_shot_pct = mean(open_shot_pct)
  ) %>%
  arrange(desc(open_shot_pct)) %>%
  left_join(offensive_rating, by="bbr_team_id")
```

```{r}
ggplot(data=os_pct_offense, mapping=aes(x=ORtg, y=open_shot_pct, color=win_pct)) + 
  geom_point(size=2) + 
  geom_smooth(method = lm) +  
  geom_text_repel(aes(label=bbr_team_id)) + 
  labs(x = "Points Scored per 100 Possessions", 
       y = "% of Shots Open on Offense",
       color = "Win %") + 
  scale_color_gradient(low = "blue", high = "red")
```


```{r}
defensive_rating <- team_season%>%
  select(Tm, win_pct, DRtg) %>%
  rename(bbr_team_id = Tm)


os_pct_defense <- league_defense_summary %>%
  group_by(team) %>%
  summarise(
    opp_open_shot_pct = mean(opp_open_shot_pct)
  ) %>%
  arrange(desc(opp_open_shot_pct)) %>%
  left_join(defensive_rating, by=c("team"="bbr_team_id"))
```


```{r}
ggplot(data=os_pct_defense, mapping=aes(x=DRtg, y=opp_open_shot_pct, color=win_pct)) + 
  geom_point(size=2) + 
  geom_smooth(method = lm) +  
  geom_text_repel(aes(label=team)) + 
  labs(x = "Points Allowed per 100 Possessions", 
       y = "% of Shots Open on Defense",
       color = "Win %") + 
  scale_color_gradient(low = "blue", high = "red")
```

